<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta charset="utf-8">
  

  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="dns-prefetch" href="https://fastly.jsdelivr.net">
  <link rel="preconnect" href="https://fastly.jsdelivr.net" crossorigin>
  <link rel="dns-prefetch" href="//unpkg.com">

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>学而时习之：C++中的函数 - RSSBOX</title>

  
    <meta name="description" content="函数 函数允许用户将程序划分为多个模块，每个模块完成特定任务。使用函数编写模块化、可复用的代码。 函数是一段可重复使用的代码块，用来完成特定任务。它能把大程序拆成小而清晰的模块，使代码更易读、更易维护。 与 C 相比，C++ 的函数还支持重载、默认实参、内联等高级特性，更加灵活。 示例代码： #include &lt;iostream&gt; using namespace std;  &amp;#x2">
<meta property="og:type" content="article">
<meta property="og:title" content="学而时习之：C++中的函数">
<meta property="og:url" content="https://rssbox.mhuig.top/rss/d2fd7096.html">
<meta property="og:site_name" content="RSSBOX">
<meta property="og:description" content="函数 函数允许用户将程序划分为多个模块，每个模块完成特定任务。使用函数编写模块化、可复用的代码。 函数是一段可重复使用的代码块，用来完成特定任务。它能把大程序拆成小而清晰的模块，使代码更易读、更易维护。 与 C 相比，C++ 的函数还支持重载、默认实参、内联等高级特性，更加灵活。 示例代码： #include &lt;iostream&gt; using namespace std;  &amp;#x2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cors.mhuig.top/?r=https://juejin.cn&url=https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eb8c65c77d9a42efbc81d077a031e7ae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Wk55CD546L5a2Q:q75.awebp?rk3s=f64ab15b&amp;x-expires=1762398184&amp;x-signature=SDsJe%2FKsJyTaLwHVo0c45QezbLM%3D">
<meta property="article:published_time" content="2025-10-30T03:03:04.000Z">
<meta property="article:modified_time" content="2025-10-30T03:03:04.000Z">
<meta property="article:author" content="MHuiG">
<meta property="article:tag" content="媒体">
<meta property="article:tag" content="掘金">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cors.mhuig.top/?r=https://juejin.cn&url=https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eb8c65c77d9a42efbc81d077a031e7ae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Wk55CD546L5a2Q:q75.awebp?rk3s=f64ab15b&amp;x-expires=1762398184&amp;x-signature=SDsJe%2FKsJyTaLwHVo0c45QezbLM%3D">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="RSSBOX" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  


  
</head>

<body>
  




  <div class="l_body" id="start">
    <aside class="l_left" layout="post">
    


<header class="header">

<div class="logo-wrap"><a class="avatar" target="_blank" rel="noopener" href="https://mhuig.top/"><div class="bg" style="opacity:0;background-image:url(https://static.mhuig.top/gh/cdn-x/placeholder@1.0.2/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/avatar.png" onerror="javascript:this.classList.add('error');this.src='https://static.mhuig.top/gh/cdn-x/placeholder@1.0.1/image/2659360.svg';"></a><a class="title" href="/"><div class="main">RSSBOX</div><div class="sub normal cap">MHuiGのRSS订阅</div><div class="sub hover cap" style="opacity:0">rssbox.mhuig.top</div></a></div>
<nav class="menu dis-select"><a class="nav-item active" href="/">RSS</a><a class="nav-item" target="_blank" rel="noopener" href="https://blog.mhuig.top/">博客</a><a class="nav-item" target="_blank" rel="noopener" href="https://mhuig.top/">关于</a></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">1. C++ 函数语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">2. 函数声明 vs 函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">3. 调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">4. C++ 函数的类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">参数传递方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">1. 值传递（Pass by Value）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">2. 引用传递（Pass by Reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">3. 指针传递（Pass by Pointer）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">默认参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">1. 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">2. 应遵循的规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">内联函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">1. 内联函数的必要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">2. 内联函数的行为特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">3.类中的内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">4.虚函数能否内联？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5. 内联函数与宏的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">1.语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">2.示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">3.应用场景</span></a></li></ol></li></ol></div></div></div>


</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/MHuiG" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://static.mhuig.top/gh/cdn-x/placeholder@1.0.3/social/08a41b181ce68.svg"></a><a class="social" href="https://music.163.com/#/user/home?id=63035382" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://static.mhuig.top/gh/cdn-x/placeholder@1.0.3/social/3845874.svg"></a><a class="social" href="/contact/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://static.mhuig.top/gh/cdn-x/placeholder@1.0.3/social/a1b00e20f425d.svg"></a></div></footer>

    </aside>
    <div class="l_main">
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E5%AA%92%E4%BD%93/">媒体</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/%E5%AA%92%E4%BD%93/%E6%8E%98%E9%87%91/">掘金</a></div><div id="post-meta">发布于&nbsp;<time datetime="2025-10-30T03:03:04.000Z">2025-10-30</time></div></div>

<article class="content md post">
<h1 class="article-title"><span>学而时习之：C++中的函数</span></h1>
<div>
<h2 data-id="heading-0">函数</h2>
<p>函数允许用户将程序划分为多个模块，每个模块完成特定任务。使用函数编写模块化、可复用的代码。</p>
<p>函数是一段可重复使用的代码块，用来完成特定任务。它能把大程序拆成小而清晰的模块，使代码更易读、更易维护。</p>
<p>与 C 相比，C++ 的函数还支持<strong>重载</strong>、<strong>默认实参</strong>、<strong>内联</strong>等高级特性，更加灵活。</p>
<p>示例代码：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<p><span class="hljs-comment">&#x2F;&#x2F; 无返回值函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&amp;#123;<br>    cout &lt;&lt; <span class="hljs-string">“GeeksforGeeks”</span> &lt;&lt; endl;<br>&amp;#125;</p>
<p><span class="hljs-comment">&#x2F;&#x2F; 带返回值函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&amp;#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&amp;#125;</p>
<p><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&amp;#123;<br>    <span class="hljs-built_in">hello</span>();                    <span class="hljs-comment">&#x2F;&#x2F; 调用无返回值函数</span><br>    <span class="hljs-type">int</span> result &#x3D; <span class="hljs-built_in">square</span>(<span class="hljs-number">5</span>);     <span class="hljs-comment">&#x2F;&#x2F; 调用带返回值函数</span><br>    cout &lt;&lt; <span class="hljs-string">“Square of 5 is: “</span> &lt;&lt; result &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&amp;#125;<br></p></code></pre><p></p>
<p>运行结果：</p>
<pre><code class="hljs language-csharp" lang="csharp">GeeksforGeeks
Square of <span class="hljs-number">5</span> <span class="hljs-keyword">is</span>: <span class="hljs-number">25</span>
</code></pre>
<p>代码说明：</p>
<ol>
<li><code>main()</code>：程序入口，从这里开始执行，负责调用其他函数。</li>
<li><code>hello()</code>：用户自定义的无参数、无返回值函数，仅打印 <code>GeeksforGeeks</code>。</li>
<li><code>square(int x)</code>：用户自定义函数，接收一个整数并返回其平方值；在 <code>main()</code> 中以 5 为实参调用，结果存入变量后输出。</li>
</ol>
<p><img class="lazy" alt="image.png" loading="lazy" referrerpolicy="no-referrer" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cors.mhuig.top/?r=https://juejin.cn&url=https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eb8c65c77d9a42efbc81d077a031e7ae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Wk55CD546L5a2Q:q75.awebp?rk3s=f64ab15b&amp;x-expires=1762398184&amp;x-signature=SDsJe%2FKsJyTaLwHVo0c45QezbLM%3D"></p>
<h3 data-id="heading-1">1. C++ 函数语法</h3>
<p>一个函数通常按以下格式书写：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function">return_type <span class="hljs-title">function_name</span><span class="hljs-params">(parameter_list)</span> </span>&#123;
    <span class="hljs-comment">// 函数体</span>
&#125;
</code></pre>
<p>各部分作用：</p>
<ul>
<li><strong>返回类型</strong>（return_type）：说明函数把什么类型的结果带回来；若无结果，写 <code>void</code>。</li>
<li><strong>函数名</strong>（function_name）：以后调用它时用的名字。</li>
<li><strong>形参列表</strong>（parameter_list）：函数期望接收的输入，可以为空。</li>
<li><strong>函数体</strong>：真正执行的代码块，调用函数时就会跑这段逻辑。</li>
</ul>
<h3 data-id="heading-2">2. 函数声明 vs 函数定义</h3>
<p><strong>函数声明</strong>（Declaration） 只向编译器“介绍”函数：给出返回类型、函数名和参数列表，<strong>不写函数体</strong>，末尾带分号。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 声明</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;
</code></pre>
<p><strong>函数定义</strong>（Definition） 同时给出函数体，即真正的实现代码。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;
    <span class="hljs-keyword">return</span> a + b;
&#125;
</code></pre>
<p>为什么需要声明？</p>
<ol>
<li>如果函数<strong>定义在 main 之后</strong>（或别的源文件里），编译器在第一次遇到调用语句时还不知道有这么个函数，会报错。</li>
<li>提前写一份声明，编译器就能先知道它的“签名”，从而检查调用是否正确。</li>
</ol>
<p>一句话：</p>
<ul>
<li><strong>声明</strong>告诉编译器“有个函数长这样”；</li>
<li><strong>定义</strong>把“具体怎么做”补全。</li>
</ul>
<h3 data-id="heading-3">3. 调用函数</h3>
<p>函数一旦定义完成，只需写出函数名并加上括号 <code>()</code>，程序就会跳进去执行其中的代码。</p>
<ul>
<li>如果函数需要参数，把实参按顺序放进括号；</li>
<li>如果不需要参数，就留空括号。</li>
</ul>
<p>示例代码：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<p><span class="hljs-comment">&#x2F;&#x2F; 无参数、无返回值的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">greet</span><span class="hljs-params">()</span> </span>&amp;#123;<br>    cout &lt;&lt; <span class="hljs-string">“Welcome to C++ Programming!”</span> &lt;&lt; endl;<br>&amp;#125;</p>
<p><span class="hljs-comment">&#x2F;&#x2F; 有参数、有返回值的函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&amp;#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&amp;#125;</p>
<p><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&amp;#123;<br>    <span class="hljs-built_in">greet</span>();                           <span class="hljs-comment">&#x2F;&#x2F; 调用 greet()</span><br>    <span class="hljs-type">int</span> result &#x3D; <span class="hljs-built_in">multiply</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);       <span class="hljs-comment">&#x2F;&#x2F; 调用 multiply()</span><br>    cout &lt;&lt; <span class="hljs-string">“Multiplication result: “</span> &lt;&lt; result &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&amp;#125;<br></p></code></pre><p></p>
<p>运行结果：</p>
<pre><code class="hljs language-css" lang="css">Welcome <span class="hljs-selector-tag">to</span> C++ Programming!
Multiplication result: <span class="hljs-number">20</span>
</code></pre>
<p>说明：</p>
<ul>
<li><code>greet()</code> 只是打印欢迎信息，调用时写 <code>greet();</code> 即可。</li>
<li><code>multiply(4, 5)</code> 把 4 和 5 传进去，返回 20 并存入 <code>result</code>。</li>
</ul>
<p>通过多次调用同一函数、传入不同实参，就能以结构化、简洁的方式重复完成任务。</p>
<h3 data-id="heading-4">4. C++ 函数的类型</h3>
<p>在 C++ 中，函数分两类：</p>
<ol>
<li>
<p><strong>库函数</strong><br>
由 C++ 标准库直接提供，例如 <code>std::cout</code>、<code>std::sqrt()</code>、<code>std::abs()</code>、<code>std::getline()</code> 等。只要包含对应头文件（<code>&lt;iostream&gt;</code>、<code>&lt;cmath&gt;</code>、<code>&lt;string&gt;</code> 等）即可调用。</p>
</li>
<li>
<p><strong>用户自定义函数</strong><br>
程序员自己写的函数，用来完成特定任务。</p>
</li>
</ol>
<h2 data-id="heading-5">参数传递方式</h2>
<p>C++ 中的参数传递技术。在 C++ 中，可以在调用函数时将数据发送给函数以执行操作。这些数据称为参数（parameters）或实参（arguments），并且 C++ 提供了多种参数传递方式。本文将讨论 C++ 中的各种参数传递技术。</p>
<p>在了解具体技术之前，先弄清以下术语的区别：</p>
<ul>
<li><strong>形式参数（Formal Parameters）</strong>：函数参数列表中用作占位符的变量，也简称“参数”。</li>
<li><strong>实际参数（Actual Parameters）</strong>：函数调用时传入的表达式或值，也叫“实参”。</li>
</ul>
<p>C++ 中有 3 种不同的参数传递方法：</p>
<hr>
<h3 data-id="heading-6">1. 值传递（Pass by Value）</h3>
<p>在值传递方式中，变量的值被复制一份再传给函数。因此，函数内部对参数的任何修改都不会影响调用者中该变量的原始值。该方法简单、易懂、易实现，但对于大型数据结构不推荐，因为涉及拷贝开销。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<p><span class="hljs-comment">&#x2F;&#x2F; 参数按值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&amp;#123;<br>    a &#x3D; <span class="hljs-number">22</span>;  <span class="hljs-comment">&#x2F;&#x2F; 仅修改局部副本</span><br>&amp;#125;</p>
<p><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&amp;#123;<br>    <span class="hljs-type">int</span> x &#x3D; <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">change</span>(x);  <span class="hljs-comment">&#x2F;&#x2F; 将 x 按值传入</span><br>    cout &lt;&lt; x;  <span class="hljs-comment">&#x2F;&#x2F; 输出仍为 5</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&amp;#125;<br></p></code></pre><p></p>
<p><strong>输出</strong></p>
<pre><code class="hljs">5
</code></pre>
<h3 data-id="heading-7">2. 引用传递（Pass by Reference）</h3>
<p>在引用传递方式中，不再传递实参的值，而是传递实参的引用。这样函数内部对参数的修改会直接影响原始变量。适用于需要修改调用者数据或传递大型对象时。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<p><span class="hljs-comment">&#x2F;&#x2F; 参数按引用传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a)</span> </span>&amp;#123;<br>    a &#x3D; <span class="hljs-number">22</span>;  <span class="hljs-comment">&#x2F;&#x2F; 直接修改原变量</span><br>&amp;#125;</p>
<p><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&amp;#123;<br>    <span class="hljs-type">int</span> x &#x3D; <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">change</span>(x);  <span class="hljs-comment">&#x2F;&#x2F; 将 x 以引用方式传入</span><br>    cout &lt;&lt; x;  <span class="hljs-comment">&#x2F;&#x2F; 输出 22</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&amp;#125;<br></p></code></pre><p></p>
<p><strong>输出</strong></p>
<pre><code class="hljs">22
</code></pre>
<p>只需把形参 <code>a</code> 声明为引用类型，就从“值传递”变成了“引用传递”。</p>
<hr>
<h3 data-id="heading-8">3. 指针传递（Pass by Pointer）</h3>
<p>指针传递与引用传递非常相似，唯一区别是我们把实参的原始地址（指针）作为参数传给函数，而不是引用。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<p><span class="hljs-comment">&#x2F;&#x2F; 参数按指针传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span>* a)</span> </span>&amp;#123;<br>    *a &#x3D; <span class="hljs-number">22</span>;  <span class="hljs-comment">&#x2F;&#x2F; 通过地址修改原变量</span><br>&amp;#125;</p>
<p><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&amp;#123;<br>    <span class="hljs-type">int</span> x &#x3D; <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">change</span>(&amp;x);  <span class="hljs-comment">&#x2F;&#x2F; 传入 x 的地址</span><br>    cout &lt;&lt; x;   <span class="hljs-comment">&#x2F;&#x2F; 输出 22</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&amp;#125;<br></p></code></pre><p></p>
<p><strong>输出</strong></p>
<pre><code class="hljs">22
</code></pre>
<p>虽然也能修改原始值，但程序复杂度增加：需要小心解引用、取地址等操作。因此，通常优先使用引用传递而非指针传递。</p>
<h2 data-id="heading-9">默认参数</h2>
<p>C++ 中的默认参数。默认参数是在<strong>函数声明时为形参给出的值</strong>。如果调用函数时没有为这些形参提供实参，编译器会自动使用该默认值。</p>
<p>规则：</p>
<ol>
<li>默认参数必须出现在参数列表的最右侧。</li>
<li>一旦某个参数被指定为默认参数，其右侧的所有参数都必须也带有默认值。</li>
<li>建议把默认参数写在函数声明中（通常在头文件里）。</li>
</ol>
<p>示例代码：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<p><span class="hljs-comment">&#x2F;&#x2F; 带默认参数的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a &#x3D; <span class="hljs-number">10</span>)</span><br></span>&amp;#123;<br>    cout &lt;&lt; a &lt;&lt; endl;<br>&amp;#125;</p>
<p><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&amp;#123;<br>    <span class="hljs-built_in">f</span>();      <span class="hljs-comment">&#x2F;&#x2F; 使用默认值，输出 10</span><br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">221</span>);   <span class="hljs-comment">&#x2F;&#x2F; 使用传入值，输出 221</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&amp;#125;<br></p></code></pre><p></p>
<p>运行结果：<br>
10<br>
221</p>
<p>解释：<br>
函数 f 的形参 a 设有默认值 10。<br>
第一次调用 f() 没有传实参，a 取默认值 10 并打印；<br>
第二次调用 f(221) 把 221 传给 a，因此打印 221。</p>
<h3 data-id="heading-10">1. 语法</h3>
<p>在函数声明中，通过给形参赋值来指定默认参数：</p>
<pre><code class="hljs language-ini" lang="ini">return_type 函数名(<span class="hljs-attr">p1</span> = v1,  p2 = v2,   ...)<span class="hljs-comment">;</span>

<p>其中 v1、v2…… 分别是形参 p1、p2…… 的默认值<br></p></code></pre><p></p>
<h3 data-id="heading-11">2. 应遵循的规则</h3>
<p>使用默认参数时，请记住以下重要规则与最佳实践：</p>
<p>**（1）默认参数必须写在函数声明中  **</p>
<p>默认参数只能出现在函数声明（原型）里。如果函数的声明与定义分开，则默认值应放在声明处，而不是定义处。</p>
<p>示例：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 声明：带默认参数</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x = <span class="hljs-number">10</span>)</span></span>;

<p><span class="hljs-comment">&#x2F;&#x2F; 定义：不再写默认参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br></span>&amp;#123;<br>    cout &lt;&lt; <span class="hljs-string">“Value: “</span> &lt;&lt; x &lt;&lt; endl;<br>&amp;#125;<br></p></code></pre><p></p>
<p><strong>（2）默认参数不能被修改</strong></p>
<p>一旦在声明中指定了默认参数，就不能在函数定义里再次修改。如果在定义处尝试给出不同的默认值，编译器会报错。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 声明</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>)</span></span>;

<p><span class="hljs-comment">&#x2F;&#x2F; 错误：定义处试图修改默认值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a &#x3D; <span class="hljs-number">222</span>)</span><br></span>&amp;#123;<br>    <span class="hljs-comment">&#x2F;&#x2F; 语句</span><br>&amp;#125;<br></p></code></pre><p></p>
<p><strong>（3）默认参数必须从右向左依次给出</strong></p>
<p>对于有多个参数的函数，带默认值的形参必须位于形参列表的最右侧。也就是说，如果某个参数有了默认值，那么它右边的所有参数都必须也有默认值。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 合法</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y = <span class="hljs-number">20</span>)</span></span>;

<p><span class="hljs-comment">&#x2F;&#x2F; 非法：y 没有默认值，却出现在带默认值参数的左边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x &#x3D; <span class="hljs-number">10</span>, <span class="hljs-type">int</span> y)</span></span>;<br></p></code></pre><p></p>
<p><strong>（4）函数重载时可能产生歧义</strong></p>
<p>如果利用默认参数对函数进行重载，必须确保调用时编译器能够唯一地匹配，否则会产生二义性错误。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 合法</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>)</span></span>;

<p><span class="hljs-comment">&#x2F;&#x2F; 错误：与上一个函数签名相同（仅靠修改默认值无法区分）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a &#x3D; <span class="hljs-number">22</span>, <span class="hljs-type">int</span> b &#x3D; <span class="hljs-number">2</span>)</span></span>;</p>
<p><span class="hljs-comment">&#x2F;&#x2F; 错误：与第一个函数在只传一个参数时无法区分</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;</p>
<p><span class="hljs-comment">&#x2F;&#x2F; 错误：语法本身就非法（参数 b 缺少类型）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a, b)</span><br></span></p></code></pre><p></p>
<h2 data-id="heading-12">内联函数</h2>
<p>C++ 中的内联函数，内联函数是 C++ 中的一种函数，其代码在编译时会在调用点展开，从而减少函数调用的开销。</p>
<p><code>inline</code> 关键字建议将函数调用替换为函数体代码以降低开销。<br>
但内联只是“请求”，编译器可以拒绝。<br>
如果函数体内出现循环、递归、static 变量、switch/goto、non-void 函数缺少 return 语句，编译器通常会放弃内联。</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<p><span class="hljs-comment">&#x2F;&#x2F; 内联函数：计算两数之和</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&amp;#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&amp;#125;</p>
<p><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&amp;#123;<br>    <span class="hljs-type">int</span> num1 &#x3D; <span class="hljs-number">5</span>, num2 &#x3D; <span class="hljs-number">10</span>;</p>
<pre><code>&lt;span class=&quot;hljs-comment&quot;&gt;// 调用内联函数&lt;/span&gt;
&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; result = getSum(num1, num2);

&lt;span class=&quot;hljs-comment&quot;&gt;// 输出结果&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Sum: %d\n&quot;&lt;/span&gt;, result);

&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
</code></pre>
<p>&amp;#125;<br></p></code></pre><p></p>
<pre><code class="hljs language-运行结果" lang="运行结果">Sum: 15
</code></pre>
<h3 data-id="heading-13">1. 内联函数的必要性</h3>
<p>函数调用需要保存返回地址、传递参数、恢复现场等操作，这些开销对于体积小且被频繁调用的函数来说可能非常显著。<br>
内联函数通过把函数体直接“展开”到调用处，省去了上述步骤，从而提升效率。<br>
只有当“函数调用本身的开销”大于“函数体内代码的执行时间”时，使用内联才有实际意义。</p>
<h3 data-id="heading-14">2. 内联函数的行为特征</h3>
<p>（1）. 内联函数在编译阶段将其函数体“展开”到调用处，不会生成独立的符号。<br>
（2）. 是否真正内联由编译器决定，它可以拒绝内联请求。<br>
（3）. 若函数未被内联，就会生成一份实体定义；当该定义出现在头文件并被多个源文件包含时，可能引发“多重定义”链接错误。<br>
（4）. C++ 规定：完全相同的 inline 函数可以出现在多个翻译单元中，因此把它们写在头文件里、用于模板或类定义时都是安全的。</p>
<h3 data-id="heading-15">3.类中的内联函数</h3>
<p>（1） 在类体内给出完整定义的函数自动成为隐式内联函数，因此所有内联限制对它们同样适用。<br>
（2） 如果想“显式”地把某个成员函数声明为内联，可先在类内只给出声明，然后在类外定义时加上 inline 关键字。</p>
<p>示例</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<p><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &amp;#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">&#x2F;&#x2F; 仅声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;<br>&amp;#125;;</p>
<p><span class="hljs-comment">&#x2F;&#x2F; 类外定义并显式指定为内联</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">A::square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&amp;#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&amp;#125;</p>
<p><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&amp;#123;<br>    A obj;<br>    cout &lt;&lt; obj.<span class="hljs-built_in">square</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">&#x2F;&#x2F; 输出 9</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&amp;#125;<br></p></code></pre><p></p>
<h3 data-id="heading-16">4.虚函数能否内联？</h3>
<p>虚函数在运行期根据对象的实际类型动态解析，而内联是在编译期把函数体直接展开。<br>
由于编译期无法确定最终调用的是哪个虚函数版本，因此无法实现内联。<br>
简言之：运行期解析与编译期展开冲突，导致虚函数无法被内联。</p>
<h3 data-id="heading-17">5. 内联函数与宏的对比</h3>
<p>在 C++ 中，内联函数和宏都能减少函数调用开销、提升执行速度，但两者在行为上有本质区别。内联函数具备更好的安全性与作用域控制，而宏只是简单的预处理替换。主要差异如下：</p>
<table><thead><tr><th>方面</th><th>内联函数</th><th>宏</th></tr></thead><tbody><tr><td>定义方式</td><td>使用 <code>inline</code> 关键字定义的函数</td><td>使用 <code>#define</code> 定义的预处理指令</td></tr><tr><td>作用域与类型检查</td><td>遵循函数的作用域规则，由编译器做类型检查</td><td>无作用域概念，也不做类型检查，仅做纯文本替换</td></tr><tr><td>实参求值</td><td>实参仅被求值一次</td><td>实参在替换后的表达式里可能被多次求值</td></tr><tr><td>处理阶段</td><td>由编译器处理</td><td>由预处理器处理</td></tr><tr><td>访问类私有成员</td><td>可以访问类的私有成员</td><td>无法访问类的私有成员</td></tr><tr><td>执行开销</td><td>编译器可视情况拒绝内联（如函数体过大）</td><td>总是被无条件地展开替换</td></tr><tr><td>递归</td><td>支持递归调用</td><td>不支持递归</td></tr></tbody></table>
<h2 data-id="heading-18">Lambda 表达式</h2>
<p>C++ 中的 Lambda 表达式。C++11 引入了 lambda 表达式，用来定义“即用即弃”的小段内联函数，通常不需要名字。它们最常作为回调函数出现在 STL 算法里。</p>
<p>示例：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<p><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&amp;#123;<br>    <span class="hljs-comment">&#x2F;&#x2F; 定义一个 lambda：把输入的整数翻倍</span><br>    <span class="hljs-keyword">auto</span> res &#x3D; [](<span class="hljs-type">int</span> x) &amp;#123;<br>        <span class="hljs-keyword">return</span> x + x;<br>    &amp;#125;;</p>
<pre><code>&lt;span class=&quot;hljs-comment&quot;&gt;// 调用 lambda&lt;/span&gt;
cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;res&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);   &lt;span class=&quot;hljs-comment&quot;&gt;// 输出 10&lt;/span&gt;

&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
</code></pre>
<p>&amp;#125;<br></p></code></pre><p></p>
<p>上面的 lambda 接受一个整数 <code>x</code>，返回 <code>x + x</code>。<code>res(5)</code> 的结果为 10，即把 5 翻倍。</p>
<h3 data-id="heading-19">1.语法</h3>
<pre><code class="hljs language-rust" lang="rust">[capture-clause] (parameters) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">return</span>-<span class="hljs-keyword">type</span> &#123;
    <span class="hljs-comment">// 函数体</span>
&#125;
</code></pre>
<p>(1).返回类型(<strong><strong>Return Type</strong></strong>)<br>
编译器通常能自行推导出返回类型，一般不必显式写出；但在复杂情况（如条件分支返回不同类型）下需手动指定。</p>
<p>(2).参数列表(<strong><strong>Parameters</strong></strong>)<br>
与普通函数参数完全一致。</p>
<p>(3).捕获列表(<strong><strong>Capture Clause</strong></strong>)<br>
lambda 比普通函数更强大：可通过捕获列表访问外层作用域的变量。三种常见方式：</p>
<ul>
<li><code>[&amp;]</code>：全部外部变量<strong>按引用</strong>捕获</li>
<li><code>[=]</code>：全部外部变量<strong>按值</strong>捕获</li>
<li><code>[a, &amp;b]</code>：<code>a</code> 按值捕获，<code>b</code> 按引用捕获</li>
</ul>
<p>若捕获列表为空 <code>[]</code>，则只能使用 lambda 内部自建的局部变量。</p>
<p>示例程序</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<p><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; v)</span> </span>&amp;#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : v) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">“ “</span>;<br>    cout &lt;&lt; endl;<br>&amp;#125;</p>
<p><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&amp;#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v1, v2;</p>
<pre><code>&lt;span class=&quot;hljs-comment&quot;&gt;// 全部按引用捕获&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; byRef = [&amp;amp;](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; m) &amp;#123;
    v1.&lt;span class=&quot;hljs-built_in&quot;&gt;push_back&lt;/span&gt;(m);
    v2.&lt;span class=&quot;hljs-built_in&quot;&gt;push_back&lt;/span&gt;(m);
&amp;#125;;

&lt;span class=&quot;hljs-comment&quot;&gt;// 全部按值捕获（此处代码仍用 [&amp;amp;] 实为引用，注释应为笔误）&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; byVal = [&amp;amp;](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; m) &amp;#123;
    v1.&lt;span class=&quot;hljs-built_in&quot;&gt;push_back&lt;/span&gt;(m);
    v2.&lt;span class=&quot;hljs-built_in&quot;&gt;push_back&lt;/span&gt;(m);
&amp;#125;;

&lt;span class=&quot;hljs-comment&quot;&gt;// 分别指定捕获方式&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; mixed = [&amp;amp;v1, &amp;amp;v2](&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; m) &amp;#123;
    v1.&lt;span class=&quot;hljs-built_in&quot;&gt;push_back&lt;/span&gt;(m);
    v2.&lt;span class=&quot;hljs-built_in&quot;&gt;push_back&lt;/span&gt;(m);
&amp;#125;;

&lt;span class=&quot;hljs-built_in&quot;&gt;byRef&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;);   &lt;span class=&quot;hljs-comment&quot;&gt;// 往原 v1、v2 各推 20&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;byVal&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;234&lt;/span&gt;);  &lt;span class=&quot;hljs-comment&quot;&gt;// 同上（因仍是引用）&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;mixed&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);   &lt;span class=&quot;hljs-comment&quot;&gt;// 再往原 v1、v2 各推 10&lt;/span&gt;

&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(v1);   &lt;span class=&quot;hljs-comment&quot;&gt;// 20 234 10&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(v2);   &lt;span class=&quot;hljs-comment&quot;&gt;// 20 234 10&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
</code></pre>
<p>&amp;#125;<br></p></code></pre><p></p>
<p>运行结果</p>
<pre><code class="hljs">20 234 10 
20 234 10 
</code></pre>
<p>补充说明<br>
若真的<strong>按值捕获</strong> <code>[=]</code>，默认情况下捕获的变量在 lambda 体内是 <code>const</code>，需要修改时应加上 <code>mutable</code> 关键字，例如：</p>
<pre><code class="hljs language-cpp" lang="cpp">[=](<span class="hljs-type">int</span> m) <span class="hljs-keyword">mutable</span> &#123; <span class="hljs-comment">/* 可修改按值捕获的副本 */</span> &#125;
</code></pre>
<h3 data-id="heading-20">2.示例</h3>
<p>Lambda 表达式在 STL 中被广泛用作“回调”——也就是当作参数传递的小函数。下面通过两个例子说明：</p>
<p>示例 1：将 vector 降序排序</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<p><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&amp;#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v &#x3D; &amp;#123;<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>&amp;#125;;</p>
<pre><code>&lt;span class=&quot;hljs-comment&quot;&gt;// 用 lambda 按降序排序&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;sort&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [](&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;amp; a, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;amp; b) &amp;#123;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a &amp;gt; b;
&amp;#125;);

&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x : v)
    cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;;   &lt;span class=&quot;hljs-comment&quot;&gt;// 9 8 5 3 2 1&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
</code></pre>
<p>&amp;#125;<br></p></code></pre><p></p>
<p>示例 2：查找第一个能被 3 整除的元素</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<p><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&amp;#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v &#x3D; &amp;#123;<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>&amp;#125;;</p>
<pre><code>&lt;span class=&quot;hljs-comment&quot;&gt;// 用 lambda 查找第一个 %3==0 的元素&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; it = &lt;span class=&quot;hljs-built_in&quot;&gt;find_if&lt;/span&gt;(v.&lt;span class=&quot;hljs-built_in&quot;&gt;begin&lt;/span&gt;(), v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;(), [](&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;amp; a) &amp;#123;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a % &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
&amp;#125;);

&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (it != v.&lt;span class=&quot;hljs-built_in&quot;&gt;end&lt;/span&gt;()) cout &amp;lt;&amp;lt; *it;   &lt;span class=&quot;hljs-comment&quot;&gt;// 输出 3&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;No such element&quot;&lt;/span&gt;;
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
</code></pre>
<p>&amp;#125;<br></p></code></pre><p></p>
<h3 data-id="heading-21">3.应用场景</h3>
<p>Lambda 表达式诞生的初衷，就是“用内联、匿名的定义”取代各种回调函数。以下是 C++ 中 lambda 最常见的用武之地：</p>
<ol>
<li>
<p>内联匿名函数<br>
在需要的地方当场写一小段逻辑，无需费心起名字。</p>
</li>
<li>
<p>STL 算法<br>
把自定义的比较、变换逻辑直接塞进 <code>sort</code>、<code>for_each</code>、<code>find_if</code> 等算法。</p>
</li>
<li>
<p>回调与事件处理<br>
异步操作或 GUI 事件需要回调时，直接写 lambda，不用再单独声明函数。</p>
</li>
<li>
<p>多线程与并发<br>
创建线程时顺手扔一个 lambda 进去，快速完成一次性小任务。</p>
</li>
<li>
<p>容器的自定义比较器<br>
为 <code>priority_queue</code>、<code>set</code>、<code>map</code> 等容器提供“即席”排序规则，无需另写类或函数对象。</p>
</li>
</ol>
</div>

<div>
<div class="tag-plugin link dis-select"><a class="link-card plain" title="学而时习之：C++中的函数" href="https://juejin.cn/post/7566598262560604210" target="_blank" rel="external nofollow noopener noreferrer"><div class="left"><span class="title">学而时习之：C++中的函数</span><span class="desc fs12">https://juejin.cn/post/7566598262560604210</span></div><div class="right"><div class="lazy img" data-bg="https://static.mhuig.top/gh/cdn-x/placeholder@1.0.1/link/8f277b4ee0ecd.svg"></div></div></a></div>
</div>



<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/me-shaon/GLWTPL/blob/master/translations/LICENSE_zh-CN">GLWT（Good Luck With That，祝你好运）公共许可证</a> 许可协议。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><a id="next" href="/rss/e8e18acd.html">Sora连更三大新功能！一键打造IP形象，限时免注册码抢占安卓市场<span class="note">较早</span></a><div class="line"></div><a id="prev" href="/rss/aaf1746b.html">全球首个具身智能开放平台来了！让大模型长出“身体”，像人一样自然表达交互<span class="note">较新</span></a></section></div>


<div class="related-wrap reveal" id="related-posts">
    <section class="header">
      <div class="title cap theme">您可能感兴趣的文章</div>
    </section>
    <section class="body">
    <div class="related-posts"><a class="item" href="/rss/94ebdae8.html" title="AI产品发展必经之路： 从售卖工具到售卖解决方案"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cors.mhuig.top/?r=https://juejin.cn&url=https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3075c572d5cc4f84960e8cfbc7584378~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2O5rSb:q75.awebp?rk3s=f64ab15b&x-expires=1762410050&x-signature=yehyzPbxYZn8kN1pMUld8gAahKw%3D"></div><span class="title">AI产品发展必经之路： 从售卖工具到售卖解决方案</span></a><a class="item" href="/rss/f98299b5.html" title="Python编程实战：日期处理与数学算法综合练习"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://picsum.photos/400/300?random=9464"></div><span class="title">Python编程实战：日期处理与数学算法综合练习</span></a><a class="item" href="/rss/27abc8d1.html" title="K8s Service会话保持导致Pod流量不均：故障排查与深度解析"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://picsum.photos/400/300?random=5301"></div><span class="title">K8s Service会话保持导致Pod流量不均：故障排查与深度解析</span></a><a class="item" href="/rss/f560986c.html" title="iOS基础问题整理"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://picsum.photos/400/300?random=2466"></div><span class="title">iOS基础问题整理</span></a><a class="item" href="/rss/30942235.html" title="RIVAL：面向机器翻译的迭代对抗强化学习"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cors.mhuig.top/?r=https://juejin.cn&url=https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7472fc7f373d40ca931c42a2bb217027~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOU5ZOp5ZOU5ZOp5oqA5pyv:q75.awebp?rk3s=f64ab15b&x-expires=1762488137&x-signature=uKIdVTbYaU6gkSIWY6b9VMdh6LE%3D"></div><span class="title">RIVAL：面向机器翻译的迭代对抗强化学习</span></a><a class="item" href="/rss/f3aae144.html" title="一网打尽：手把手教你搭建PXE网络启动服务器"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://picsum.photos/400/300?random=9901"></div><span class="title">一网打尽：手把手教你搭建PXE网络启动服务器</span></a><a class="item" href="/rss/8fd20786.html" title="上传项目至GitHub与从Github克隆项目"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://picsum.photos/400/300?random=3707"></div><span class="title">上传项目至GitHub与从Github克隆项目</span></a><a class="item" href="/rss/c4e8ca55.html" title="告别Div地狱：现代HTML的语义化编程革命"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://picsum.photos/400/300?random=2628"></div><span class="title">告别Div地狱：现代HTML的语义化编程革命</span></a><a class="item" href="/rss/1cd95816.html" title="大语言模型是如何听懂并会说人话的"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cors.mhuig.top/?r=https://juejin.cn&url=https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f73f48697a264e9b9fd715ddb4860435~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiO5byA5Y-R5ZCM6KGM:q75.awebp?rk3s=f64ab15b&x-expires=1762511211&x-signature=GH1pwXffHHALfU6MC07XPmtF9oA%3D"></div><span class="title">大语言模型是如何听懂并会说人话的</span></a><a class="item" href="/rss/499ddaa8.html" title="对 GPT 5 模型路由机制的深度解析"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cors.mhuig.top/?r=https://juejin.cn&url=https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b22ce078a1ea437dad51cfba2933d500~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&x-expires=1762478701&x-signature=RvWI8QrUl%2FXHJUCZUvf3jEHgXnU%3D"></div><span class="title">对 GPT 5 模型路由机制的深度解析</span></a><a class="item" href="/rss/65d5b4e1.html" title="现代JavaScript字符串处理：从基础语法到模板字符串的深度演进与技术实践"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://picsum.photos/400/300?random=9701"></div><span class="title">现代JavaScript字符串处理：从基础语法到模板字符串的深度演进与技术实践</span></a><a class="item" href="/rss/a4dd8675.html" title="翻译：苹果那传奇般的细节关注去哪儿了？"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cors.mhuig.top/?r=https://juejin.cn&url=https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/04906cb5825f40d49bb8be1d09af2721~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSnVjaGVjYXI=:q75.awebp?rk3s=f64ab15b&x-expires=1762481178&x-signature=Uk%2F6x%2FkQ47E1xnyhXluU8G1HKE4%3D"></div><span class="title">翻译：苹果那传奇般的细节关注去哪儿了？</span></a><a class="item" href="/rss/cb218f94.html" title="改变世界的编程语言MoonBit：配置系统介绍(下)"><div class="img"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://picsum.photos/400/300?random=9821"></div><span class="title">改变世界的编程语言MoonBit：配置系统介绍(下)</span></a></div></section></div>





      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">RSS</span><a href="/">近期</a><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs14">Support</span><a target="_blank" rel="noopener" href="https://blog.mhuig.top/">博客</a><a target="_blank" rel="noopener" href="https://api.mhuig.top/">API</a><a target="_blank" rel="noopener" href="https://ssl.mhuig.top/">SSL Status</a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://mhuig.instatus.com/">Status Monitors</a></div><div class="sitemap-group"><span class="fs14">社交</span><a target="_blank" rel="noopener" href="https://blog.mhuig.top/pages/friends/">友链</a><a target="_blank" rel="noopener" href="https://blog.mhuig.top/pages/about/">留言板</a></div><div class="sitemap-group"><span class="fs14">更多</span><a target="_blank" rel="noopener" href="https://mhuig.top/">关于我</a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/MHuiG">GitHub</a><a href="/contact/">Contact</a><a href="/privacy-policy/">隐私政策</a></div></div><div class="text"><p>本站由 <a target="_blank" rel="noopener" href="https://mhuig.top/">MHuiG</a> 使用 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建，您可以在 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/MHG-LAB/RSSBOX">GitHub</a> 找到本站源码<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/me-shaon/GLWTPL/blob/master/translations/LICENSE_zh-CN">GLWT（Good Luck With That，祝你好运）公共许可证</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class="float-panel mobile-only blur" style="display:none">
  <button type="button" class="sidebar-toggle mobile" onclick="sidebar.toggle()">
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewbox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"/><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"/></svg>
  </button>
</div>

    </div>
  </div>
  <div class="scripts">
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.9.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://static.mhuig.top/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://static.mhuig.top/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://static.mhuig.top/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://static.mhuig.top/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://static.mhuig.top/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://static.mhuig.top/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://static.mhuig.top/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img,article.content img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti/umd/heti.min.css","js":"https://unpkg.com/heti/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
